import os
import uuid
from typing import Optional, List, Dict, Any, Union
from pydantic import BaseModel
from langchain_core.documents import Document
from langchain_core.messages import AIMessage, BaseMessage
from supabase import create_client, Client
from shared.src.types import (
    CustomModelConfig,
    ArtifactCodeV3,
    ArtifactMarkdownV3,
    Reflections,
    ContextDocument,
    SearchResult,
    ExaMetadata
)
from shared.src.constants import (
    CONTEXT_DOCUMENTS_NAMESPACE,
    OC_WEB_SEARCH_RESULTS_MESSAGE_KEY
)

def format_reflections(
    reflections: Reflections,
    extra: Optional[Dict[str, bool]] = None
) -> str:
    if extra is None:
        extra = {}
        
    if extra.get('only_style') and extra.get('only_content'):
        raise ValueError("Cannot specify both only_style and only_content as True")

    # Process style rules
    style_rules = reflections.style_rules
    style_str = "No style guidelines found."
    if isinstance(style_rules, list):
        style_str = "- " + "\n- ".join(style_rules)
    else:
        print(f"Invalid style rules format: {type(style_rules)}")

    # Process content rules
    content_rules = reflections.content
    content_str = "No memories/facts found."
    if isinstance(content_rules, list):
        content_str = "- " + "\n- ".join(content_rules)
    else:
        print(f"Invalid content rules format: {type(content_rules)}")

    style_section = f"""The following is a list of style guidelines previously generated by you:
<style-guidelines>
{style_str}
</style-guidelines>"""

    content_section = f"""The following is a list of memories/facts you previously generated about the user:
<user-facts>
{content_str}
</user-facts>"""

    if extra.get('only_style'):
        return style_section
    if extra.get('only_content'):
        return content_section

    return f"{style_section}\n\n{content_section}"

def ensure_store_in_config(config: dict) -> Any:
    if 'store' not in config:
        raise ValueError("`store` not found in config")
    return config['store']

async def get_formatted_reflections(config: dict) -> str:
    store = ensure_store_in_config(config)
    assistant_id = config.get('configurable', {}).get('assistant_id')
    if not assistant_id:
        return "No reflections found."
    
    memory_namespace = ["memories", assistant_id]
    memory_key = "reflection"
    
    memories = await store.get(memory_namespace, memory_key)
    if memories and 'value' in memories:
        return format_reflections(memories['value'])
    return "No reflections found."

def format_artifact_content(
    content: Union[ArtifactMarkdownV3, ArtifactCodeV3],
    shorten_content: bool = False
) -> str:
    if isinstance(content, ArtifactCodeV3):
        artifact_content = content.code[:500] if shorten_content else content.code
    else:
        artifact_content = content.full_markdown[:500] if shorten_content else content.full_markdown
    
    return f"Title: {content.title}\nArtifact type: {content.type}\nContent: {artifact_content}"

def format_artifact_content_with_template(
    template: str,
    content: Union[ArtifactMarkdownV3, ArtifactCodeV3],
    shorten_content: bool = False
) -> str:
    return template.replace(
        "{artifact}",
        format_artifact_content(content, shorten_content)
    )

def get_model_config(config: dict) -> dict:
    model_provider = config.get('configurable', {}).get('model_provider')
    model_name = config.get('configurable', {}).get('model_name', '')
    
    if model_provider == "azure_openai":
        return {
            "model_name": model_name,
            "model_provider": "azure_openai",
            "azure_config": {
                "azure_openai_api_key": os.getenv("_AZURE_OPENAI_API_KEY", ""),
                "azure_openai_api_instance_name": os.getenv("_AZURE_OPENAI_API_INSTANCE_NAME", ""),
                "azure_openai_api_deployment_name": os.getenv("_AZURE_OPENAI_API_DEPLOYMENT_NAME", ""),
                "azure_openai_api_version": os.getenv("_AZURE_OPENAI_API_VERSION", "2024-08-01-preview"),
                "azure_openai_base_path": os.getenv("_AZURE_OPENAI_API_BASE_PATH")
            }
        }
    
    # Similar conditional blocks for other providers...
    
    return {}

async def get_user_from_config(config: dict) -> Optional[dict]:
    supabase_url = os.getenv("NEXT_PUBLIC_SUPABASE_URL")
    service_role = os.getenv("SUPABASE_SERVICE_ROLE")
    if not supabase_url or not service_role:
        return None

    access_token = config.get('configurable', {}).get('supabase_session', {}).get('access_token')
    if not access_token:
        return None

    supabase: Client = create_client(supabase_url, service_role)
    auth_res = supabase.auth.get_user(access_token)
    return auth_res.user if auth_res else None

def clean_base64(base64_string: str) -> str:
    return base64_string.split("base64,")[-1]

async def convert_pdf_to_text(base64_pdf: str) -> str:
    from PyPDF2 import PdfReader
    from io import BytesIO

    cleaned = clean_base64(base64_pdf)
    pdf_bytes = BytesIO(bytes.fromhex(cleaned))
    reader = PdfReader(pdf_bytes)
    text = "\n".join([page.extract_text() for page in reader.pages])
    return text

async def create_context_document_messages(documents: List[ContextDocument], provider: str) -> List[dict]:
    messages = []
    for doc in documents:
        if doc.type == "application/pdf":
            text = await convert_pdf_to_text(doc.data)
            messages.append({"type": "text", "text": text})
        elif doc.type.startswith("text/"):
            messages.append({"type": "text", "text": doc.data})
    return messages

def create_ai_message_from_web_results(web_results: List[SearchResult]) -> AIMessage:
    web_results_str = "\n\n".join([
        f"""<search-result index="{idx}" publishedDate="{res.metadata.get('publishedDate', 'Unknown')}" author="{res.metadata.get('author', 'Unknown')}">
        [{res.metadata.get('title', 'Unknown title')}]({res.metadata.get('url', 'Unknown URL')})
        {res.page_content}
        </search-result>""" for idx, res in enumerate(web_results)
    ])
    
    return AIMessage(
        content=f"Here is some additional context I found from searching the web:\n\n{web_results_str}",
        additional_kwargs={
            OC_WEB_SEARCH_RESULTS_MESSAGE_KEY: True,
            "webSearchResults": web_results,
            "webSearchStatus": "done"
        }
    )

def get_string_from_content(content: Union[str, List[dict]]) -> str:
    if isinstance(content, str):
        return content
    return "\n".join([item.get("text", "") for item in content if "text" in item]) 